<!doctype html>
<html>
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Board â€” V2.4.7 Sync + Erase Hotfix</title>
<meta name="color-scheme" content="light">
<style>
  :root{ --panel-bg:#ffffffc7; --panel-border:#0000001a; --shadow:0 14px 40px #0000001f; --text:#222; --blue:#1e90ff; }
  html,body{ margin:0;height:100%;background:#fff;overscroll-behavior:none;-webkit-user-select:none;user-select:none;-webkit-touch-callout:none;touch-action:none;font:14px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:var(--text); }
  canvas{ display:block; width:100vw; height:100vh; touch-action:none; background:#fff; }
  #hud{ position:fixed; top:8px; left:8px; font:12px system-ui; background:#fff8; padding:6px 8px; border-radius:8px; pointer-events:none; z-index:5; }
  .island{ position:fixed; left:50%; top:12px; transform:translateX(-50%); display:flex; gap:10px; padding:8px 10px; border-radius:999px; background:var(--panel-bg); border:1px solid var(--panel-border); box-shadow:var(--shadow); z-index:20; }
  .chip,.toggle{ display:flex; align-items:center; gap:8px; padding:8px 12px; border-radius:999px; background:#fff; border:1px solid rgba(0,0,0,.08); cursor:pointer; }
  .toggle.active{ outline:2px solid #222; outline-offset:2px; }
  .palette{ position:fixed; left:50%; top:64px; transform:translateX(-50%); z-index:19; background:var(--panel-bg); border:1px solid var(--panel-border); border-radius:16px; box-shadow:var(--shadow); padding:12px; display:none; }
  .palette.show{ display:block; }
  .row{ display:flex; align-items:center; gap:10px; margin:8px 4px; }
  .label{ font-size:12px; opacity:.75; min-width:46px; }
  .size-preview{ width:28px; height:28px; border-radius:50%; background:#fff; border:1px solid #0000001a; display:grid; place-items:center; }
  .dot-small{ width:10px; height:10px; border-radius:50%; }
  input[type="range"]{ -webkit-appearance:none; appearance:none; width:220px; height:4px; background:linear-gradient(90deg,#e5e5e5,#cfcfcf); border-radius:999px; outline:none; }
  input[type="range"]::-webkit-slider-thumb{ -webkit-appearance:none; width:18px; height:18px; border-radius:50%; background:#fff; border:1px solid #00000026; box-shadow:0 1px 2px #0000002e; }
  .swatches{ display:grid; grid-template-columns:repeat(10,26px); gap:8px; padding-top:4px; }
  .swatch{ width:26px; height:26px; border-radius:8px; border:1px solid #0000001f; cursor:pointer; }
  .swatch.is-active{ outline:2px solid #222; outline-offset:2px; }
  .ctx{ position:fixed; z-index:30; display:none; background:#fff; border:1px solid var(--panel-border); box-shadow:var(--shadow); border-radius:12px; padding:6px; }
  .ctx.show{ display:block; }
  .ctx button{ width:100%; text-align:left; padding:8px 10px; background:#fff; border:none; border-radius:8px; font:14px system-ui; }
  .ctx button:hover{ background:#f2f2f2; }
  .rt{ position:fixed; right:8px; top:8px; z-index:25; background:var(--panel-bg); border:1px solid var(--panel-border); box-shadow:var(--shadow); padding:8px; border-radius:12px; display:flex; gap:6px; align-items:center; }
  .rt input{ width:140px; padding:6px 8px; border:1px solid #0000001f; border-radius:8px; background:#fff; }
  .badge{ padding:4px 8px; border-radius:999px; font-size:12px; background:#eee; }
  .dot{ width:16px; height:16px; border-radius:50%; border:1px solid #0000001f; }
</style>

<!-- Firebase compat -->
<script src="https://www.gstatic.com/firebasejs/10.12.3/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.3/firebase-auth-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/10.12.3/firebase-firestore-compat.js"></script>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">mode: â€”</div>

<div class="island" id="island">
  <button id="brushChip" class="chip" type="button" aria-expanded="false" aria-controls="palette">
    <span id="brushDot" class="dot" style="background:#111"></span>
    <span id="brushSizeText" class="label">2.0</span>
    <span class="label" style="opacity:.65">â–¾</span>
  </button>
  <button id="eraserToggle" class="toggle" type="button" aria-pressed="false" title="Hitâ€‘erase">ðŸ©¹ <span class="label">Hitâ€‘erase</span></button>
</div>

<div id="palette" class="palette" role="dialog" aria-modal="false" aria-label="Brush controls">
  <div class="row">
    <div class="label">Size</div>
    <div class="size-preview"><div id="sizeDot" class="dot-small"></div></div>
    <input id="sizeRange" type="range" min="0.5" max="24" step="0.5" value="2">
    <div id="sizeVal" class="label">2.0</div>
  </div>
  <div class="row" style="flex-direction:column; align-items:flex-start; margin-top:4px;">
    <div class="label" style="opacity:.75">Colors</div>
    <div id="swatches" class="swatches"></div>
  </div>
</div>

<div id="ctx" class="ctx" role="dialog" aria-modal="false">
  <button id="dupBtn" type="button">Duplicate</button>
  <button id="delBtn" type="button">Delete</button>
</div>

<div class="rt">
  <span class="badge" id="rtState">offline</span>
  <span class="badge" id="authState">auth: idle</span>
  <input id="roomInput" placeholder="room-id" />
  <button id="connectBtn" type="button">Connect</button>
</div>

<script>
(function(){
  /* ===== Mini framework / shared state ===== */
  const $=s=>document.querySelector(s);
  const cvs=$('#c'), ctx=cvs.getContext('2d',{alpha:false}), hud=$('#hud');
  const ui={
    brushChip:$('#brushChip'), palette:$('#palette'), brushDot:$('#brushDot'), brushSizeTxt:$('#brushSizeText'),
    eraserBtn:$('#eraserToggle'), sizeRange:$('#sizeRange'), sizeVal:$('#sizeVal'), sizeDot:$('#sizeDot'), swatches:$('#swatches'),
    ctxMenu:$('#ctx'), dupBtn:$('#dupBtn'), delBtn:$('#delBtn'),
    rtState:$('#rtState'), authState:$('#authState'), roomInput:$('#roomInput'), connectBtn:$('#connectBtn')
  };

  const S={
    DPR:1, raf:0, cam:{scale:1,tx:0,ty:0}, grid:{size:28,boldEvery:5,light:'rgba(0,0,0,0.08)',bold:'rgba(0,0,0,0.18)',max:700},
    brush:{w:2,color:'#111',mode:'draw'}, palette:['#111','#444','#888','#bbb','#fff','#ff4757','#ff7f50','#ffa502','#ffd32a','#2ed573','#1e90ff','#3742fa','#a55eea','#e84393','#00cec9','#16a085','#8e44ad','#2c3e50'],
    strokes:[], history:[], redo:[], sel:{active:false,shown:false,start:null,end:null, set:new Set()}, capture:'overlap',
    current:{stroke:null, erase:null, removed:null}, I:{mode:'idle', w0:null, moving:{dx:0,dy:0}},
    pen:{active:false, timer:null, GRACE:180}, pinch:null
  };
  const FIREBASE_CONFIG={
    apiKey:"AIzaSyD9w8tcdiPlX8HveEXIg2F2SiTLxRp7AN0",
    authDomain:"board-0001.firebaseapp.com",
    projectId:"board-0001",
    storageBucket:"board-0001.appspot.com",
    messagingSenderId:"350268205788",
    appId:"1:350268205788:web:d173331949eea0e52ee219",
    measurementId:"G-EX97SPDZE6"
  };
  const RT={app:null,db:null,unsub:null,client:uuid(),room:null,lastSeen:0};
  // Offline publish queue (stores actions while disconnected)
  const PUBQ=[];

  /* ===== Utils ===== */
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const getXY=(x,y)=>{const r=cvs.getBoundingClientRect();return{x:x-r.left,y:y-r.top}};
  const scrToW=(x,y)=>({x:(x-S.cam.tx)/S.cam.scale, y:(y-S.cam.ty)/S.cam.scale});
  const rect=(a,b)=>({x0:Math.min(a.x,b.x),y0:Math.min(a.y,b.y),x1:Math.max(a.x,b.x),y1:Math.max(a.y,b.y)});
  const rectHas=(r,p)=>p.x>=r.x0&&p.x<=r.x1&&p.y>=r.y0&&p.y<=r.y1;
  const boxesOverlap=(a,b)=>!(a.maxx<b.minx||b.maxx<a.minx||a.maxy<b.miny||b.maxy<a.miny);
  const baseBounds=(pts)=>pts.reduce((m,p)=>({minx:Math.min(m.minx,p.x),maxx:Math.max(m.maxx,p.x),miny:Math.min(m.miny,p.y),maxy:Math.max(m.maxy,p.y)}),{minx:1/0,miny:1/0,maxx:-1/0,maxy:-1/0});
  const withPad=(b,p)=>({minx:b.minx-p,maxx:b.maxx+p,miny:b.miny-p,maxy:b.maxy+p});
  function uuid(){return crypto.randomUUID?crypto.randomUUID():'id_'+Math.random().toString(36).slice(2)}
  const badge=(el,txt,color)=>{ el.textContent=txt; el.style.background=color; };

  /* ===== Draw core ===== */
  function resize(){ S.DPR=Math.max(1,devicePixelRatio||1); const r=cvs.getBoundingClientRect(); cvs.width=Math.round(r.width*S.DPR); cvs.height=Math.round(r.height*S.DPR); redraw(); }
  const reqDraw=()=>{ if(S.raf) return; S.raf=requestAnimationFrame(()=>{S.raf=0; redraw();}); };
  function drawBG(){ ctx.setTransform(1,0,0,1,0,0); ctx.fillStyle='#fff'; ctx.fillRect(0,0,cvs.width,cvs.height); }
  function drawGrid(){ const g=S.grid; ctx.setTransform(S.DPR*S.cam.scale,0,0,S.DPR*S.cam.scale,S.DPR*S.cam.tx,S.DPR*S.cam.ty);
    const vw=cvs.width/(S.DPR*S.cam.scale), vh=cvs.height/(S.DPR*S.cam.scale);
    const L=-S.cam.tx/S.cam.scale, T=-S.cam.ty/S.cam.scale, R=L+vw, B=T+vh;
    const count=sp=>({vx:Math.ceil(R/sp)-Math.floor(L/sp)+1, hy:Math.ceil(B/sp)-Math.floor(T/sp)+1});
    let eff=g.size; let {vx,hy}=count(eff); while((vx+hy)>g.max){ eff*=2; ({vx,hy}=count(eff)); }
    ctx.lineWidth=1/S.cam.scale; const sx=Math.floor(L/eff)*eff, ex=Math.ceil(R/eff)*eff, sy=Math.floor(T/eff)*eff, ey=Math.ceil(B/eff)*eff;
    for(let x=sx,i=Math.round(sx/eff);x<=ex;x+=eff,i++){ ctx.beginPath(); ctx.strokeStyle=(i%g.boldEvery?g.light:g.bold); ctx.moveTo(x,sy); ctx.lineTo(x,ey); ctx.stroke(); }
    for(let y=sy,j=Math.round(sy/eff);y<=ey;y+=eff,j++){ ctx.beginPath(); ctx.strokeStyle=(j%g.boldEvery?g.light:g.bold); ctx.moveTo(sx,y); ctx.lineTo(ex,y); ctx.stroke(); }
  }
  function drawStroke(s){ const p=s.pts; if(!p.length) return; ctx.setTransform(S.DPR*S.cam.scale,0,0,S.DPR*S.cam.scale,S.DPR*S.cam.tx,S.DPR*S.cam.ty);
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle=s.color; ctx.lineWidth=s.w;
    if(p.length===1){ ctx.beginPath(); ctx.arc(p[0].x,p[0].y,s.w*0.5,0,Math.PI*2); ctx.fillStyle=s.color; ctx.fill(); return; }
    for(let i=0;i<p.length-2;i++){ const a=p[i], b=p[i+1], c=p[i+2], m1={x:(a.x+b.x)/2,y:(a.y+b.y)/2}, m2={x:(b.x+c.x)/2,y:(b.y+c.y)/2}; ctx.beginPath(); ctx.moveTo(m1.x,m1.y); ctx.quadraticCurveTo(b.x,b.y,m2.x,m2.y); ctx.stroke(); }
  }
  function drawSel(){ if(!(S.sel.shown&&S.sel.start&&S.sel.end)) return; const r=rect(S.sel.start,S.sel.end);
    ctx.setTransform(S.DPR*S.cam.scale,0,0,S.DPR*S.cam.scale,S.DPR*S.cam.tx,S.DPR*S.cam.ty); ctx.save(); ctx.lineWidth=1/S.cam.scale; ctx.setLineDash([8,6]); ctx.strokeStyle='rgba(30,144,255,0.9)'; ctx.fillStyle='rgba(30,144,255,0.08)'; ctx.beginPath(); ctx.rect(r.x0,r.y0,r.x1-r.x0,r.y1-r.y0); ctx.fill(); ctx.stroke(); ctx.restore(); }
  function redraw(){ drawBG(); drawGrid(); S.strokes.forEach(drawStroke); if(S.current.stroke) drawStroke(S.current.stroke); drawSel(); }

  /* ===== Bounds & transforms ===== */
  const bOf=(s)=>{ if(!s.bounds){ const bb=baseBounds(s.pts); s.bounds=withPad(bb,s.w*0.5); } return s.bounds };
  function translateStroke(s,dx,dy){ for(const p of s.pts){ p.x+=dx; p.y+=dy; } if(s.bounds){ s.bounds.minx+=dx; s.bounds.maxx+=dx; s.bounds.miny+=dy; s.bounds.maxy+=dy; } }
  function moveSelBy(dx,dy){ for(const s of S.sel.set) translateStroke(s,dx,dy);
    S.sel.start={x:S.sel.start.x+dx,y:S.sel.start.y+dy}; S.sel.end={x:S.sel.end.x+dx,y:S.sel.end.y+dy}; }

  /* ===== Stroke / erase lifecycles ===== */
  const beginStroke=(w)=>S.current.stroke={id:uuid(),pts:[w],w:S.brush.w,color:S.brush.color};
  const addPoint=(w)=>S.current.stroke&&S.current.stroke.pts.push(w);
  function endStroke(){ if(S.current.stroke&&S.current.stroke.pts.length>=2){ S.current.stroke.bounds=bOf(S.current.stroke); S.strokes.push(S.current.stroke); S.history.push({type:'draw',stroke:S.current.stroke}); pub({type:'draw',stroke:lite(S.current.stroke)}); S.redo.length=0; } S.current.stroke=null; }

  const beginErase=(w)=>{ S.current.erase={pts:[w],w:Math.max(0.5,S.brush.w)}; S.current.removed=new Set(); };
  function eraseSeg(e1,e2,eW){ const out=[]; const sBox=(a,b,p)=>({minx:Math.min(a.x,b.x)-p,maxx:Math.max(a.x,b.x)+p,miny:Math.min(a.y,b.y)-p,maxy:Math.max(a.y,b.y)+p});
    const dPS=(p,a,b)=>{ const vx=b.x-a.x,vy=b.y-a.y,wx=p.x-a.x,wy=p.y-a.y,c1=vx*wx+vy*wy; if(c1<=0) return Math.hypot(p.x-a.x,p.y-a.y); const c2=vx*vx+vy*vy; if(c2<=0) return Math.hypot(p.x-a.x,p.y-a.y); if(c1>=c2) return Math.hypot(p.x-b.x,p.y-b.y); const t=c1/c2,px=a.x+t*vx,py=a.y+t*vy; return Math.hypot(p.x-px,p.y-py); };
    const segHits=(e1,e2,eW,Ss)=>{ if(!Ss.pts||Ss.pts.length<2) return false; const tol=Math.max(0.35,0.5*(Ss.w+eW)-0.05), ebox=sBox(e1,e2,tol); for(let j=0;j<Ss.pts.length-1;j++){ const s1=Ss.pts[j], s2=Ss.pts[j+1], sbox=sBox(s1,s2,Ss.w*0.5); if(!boxesOverlap(ebox,sbox)) continue; const md=Math.min(dPS(e1,s1,s2),dPS(e2,s1,s2),dPS(s1,e1,e2),dPS(s2,e1,e2)); if(md<=tol) return true; } return false; };
    if(!e1||!e2) return out; for(let i=S.strokes.length-1;i>=0;i--){ const s=S.strokes[i]; const sb=bOf(s); const pad={minx:sb.minx-eW,maxx:sb.maxx+eW,miny:sb.miny-eW,maxy:sb.maxy+eW}; if(!boxesOverlap(sBox(e1,e2,eW*0.6+1),pad)) continue; if(segHits(e1,e2,eW,s)) out.push(S.strokes.splice(i,1)[0]); }
    return out;
  }
  function addErase(w){ const prev=S.current.erase.pts.at(-1); S.current.erase.pts.push(w); const rm=eraseSeg(prev,w,S.current.erase.w); for(const s of rm) S.current.removed.add(s); if(rm.length) reqDraw(); }
  function endErase(){ if(S.current.removed&&S.current.removed.size){ const ids=[...S.current.removed].map(s=>s.id); S.history.push({type:'erase',strokes:[...S.current.removed]}); pub({type:'erase',ids}); S.redo.length=0; } S.current.erase=null; S.current.removed=null; S.brush.mode='draw'; ui.eraserBtn.classList.remove('active'); ui.eraserBtn.setAttribute('aria-pressed','false'); }

  /* ===== HUD / UI ===== */
  function setMode(m){ S.I.mode=m; hud.textContent='mode: '+(m==='idle'?'â€”':m); }
  function buildSwatches(){ ui.swatches.innerHTML=''; S.palette.forEach(hex=>{ const b=document.createElement('button'); b.className='swatch'; b.style.background=hex; b.dataset.color=hex; b.onclick=()=>{ S.brush.color=hex; S.brush.mode='draw'; ui.eraserBtn.classList.remove('active'); updBrushUI(); }; ui.swatches.appendChild(b); }); updBrushUI(); }
  function updBrushUI(){ ui.sizeVal.textContent=S.brush.w.toFixed(1); ui.sizeRange.value=String(S.brush.w); const d=Math.max(4,Math.min(22,S.brush.w*1.4)); ui.sizeDot.style.width=ui.sizeDot.style.height=d+'px'; ui.sizeDot.style.background=S.brush.color; ui.brushDot.style.background=S.brush.color; ui.brushSizeTxt.textContent=S.brush.w.toFixed(1); [...ui.swatches.children].forEach(el=>el.classList.toggle('is-active', el.dataset.color.toLowerCase()===S.brush.color.toLowerCase())); }
  ui.sizeRange.oninput=()=>{ S.brush.w=parseFloat(ui.sizeRange.value)||2; updBrushUI(); };
  ui.brushChip.onclick=()=>ui.palette.classList.toggle('show');
  ui.eraserBtn.onclick=()=>{ const on=ui.eraserBtn.classList.toggle('active'); ui.eraserBtn.setAttribute('aria-pressed',String(on)); S.brush.mode=on?'hit-erase':'draw'; if(on){ ui.palette.classList.remove('show'); hideMenu(); S.sel.active=false; } hud.textContent= on?'mode: Hitâ€‘erase':'mode: Pencil'; };
  addEventListener('pointerdown',e=>{ const path=e.composedPath?.()||[]; if(path.includes(ui.palette)||path.includes(ui.brushChip)||path.includes(ui.ctxMenu)) return; ui.palette.classList.remove('show'); hideMenu(); },{passive:true});
  function showMenu(x,y){ ui.ctxMenu.style.left=x+'px'; ui.ctxMenu.style.top=y+'px'; ui.ctxMenu.classList.add('show'); }
  function hideMenu(){ ui.ctxMenu.classList.remove('show'); }
  ui.ctxMenu.addEventListener('pointerdown', e=> e.stopPropagation()); ui.ctxMenu.addEventListener('click', e=> e.stopPropagation());

  /* ===== Undo / Redo / History ===== */
  function lite(s){ return {id:s.id,w:s.w,color:s.color,pts:s.pts}; }
  function pushMove(dx,dy){ const arr=[...S.sel.set]; S.history.push({type:'move',strokes:arr,dx,dy}); S.redo.length=0; pub({type:'move',ids:arr.map(s=>s.id),dx,dy}); }
  function undo(){ const a=S.history.pop(); if(!a) return; if(a.type==='draw'){ const i=S.strokes.lastIndexOf(a.stroke); if(i!==-1) S.strokes.splice(i,1); pub({type:'delete',ids:[a.stroke.id]}); }
    else if(a.type==='erase'){ S.strokes.push(...a.strokes); pub({type:'duplicate',strokes:a.strokes.map(lite)}); }
    else if(a.type==='move'){ for(const s of a.strokes) translateStroke(s,-a.dx,-a.dy); pub({type:'move',ids:a.strokes.map(s=>s.id),dx:-a.dx,dy:-a.dy}); }
    else if(a.type==='duplicate'){ for(const s of a.clones){ const i=S.strokes.indexOf(s); if(i!==-1) S.strokes.splice(i,1);} pub({type:'delete',ids:a.clones.map(s=>s.id)}); }
    else if(a.type==='delete'){ a.removed.sort((x,y)=>x.idx-y.idx).forEach(({idx,stroke})=>S.strokes.splice(idx,0,stroke)); pub({type:'duplicate',strokes:a.removed.map(({stroke:s})=>lite(s))}); }
    S.redo.push(a); reqDraw(); hud.textContent='Undo'; }
  function redo(){ const a=S.redo.pop(); if(!a) return; if(a.type==='draw'){ S.strokes.push(a.stroke); pub({type:'duplicate',strokes:[lite(a.stroke)]}); }
    else if(a.type==='erase'){ for(const s of a.strokes){ const i=S.strokes.indexOf(s); if(i!==-1) S.strokes.splice(i,1); } pub({type:'delete',ids:a.strokes.map(s=>s.id)}); }
    else if(a.type==='move'){ for(const s of a.strokes) translateStroke(s,a.dx,a.dy); pub({type:'move',ids:a.strokes.map(s=>s.id),dx:a.dx,dy:a.dy}); }
    else if(a.type==='duplicate'){ for(const s of a.clones){ if(!S.strokes.includes(s)) S.strokes.push(s);} pub({type:'duplicate',strokes:a.clones.map(lite)}); }
    else if(a.type==='delete'){ a.removed.slice().sort((a,b)=>b.idx-a.idx).forEach(({idx})=>S.strokes.splice(idx,1)); pub({type:'delete',ids:a.removed.map(({stroke:s})=>s.id)}); }
    S.history.push(a); reqDraw(); hud.textContent='Redo'; }
  addEventListener('keydown', e=>{ if((e.ctrlKey||e.metaKey)&&!e.shiftKey&&(e.key==='z'||e.key==='Z')){ e.preventDefault(); undo(); } if((e.ctrlKey||e.metaKey)&&(e.shiftKey||e.key==='y'||e.key==='Y')){ e.preventDefault(); redo(); }});

  /* ===== Realtime ===== */
  function hasCfg(cfg){ return !!(cfg && cfg.apiKey && cfg.authDomain && cfg.projectId && cfg.appId); }
  async function ensureFirebase(){ if(!hasCfg(FIREBASE_CONFIG)){ badge(ui.authState,'auth: config-missing','#fecaca'); return false; }
    if(!RT.app) RT.app=firebase.initializeApp(FIREBASE_CONFIG);
    // Create Firestore instance early and enable offline persistence (multi-tab when possible)
    RT.db=firebase.firestore();
    try{
      await RT.db.enablePersistence({synchronizeTabs:true});
      badge(ui.authState,'persistence:on','#dbeafe');
    }catch(e){
      // If failed (e.g., private mode), continue without persistence
      console.warn('persistence', e?.code||e);
      badge(ui.authState,'persistence:off','#fee2e2');
    }
    try{
      if(navigator.onLine){
        await firebase.auth().setPersistence(firebase.auth.Auth.Persistence.NONE);
        await firebase.auth().signInAnonymously();
        badge(ui.authState,'auth: signed','#d1fae5');
      }else{
        badge(ui.authState,'auth: offline','#fde68a');
      }
    }catch(e){ badge(ui.authState,'auth: anon-disabled','#fde68a'); console.warn(e?.code||e); }
    return true; }

  function pub(action){
    // If not connected, queue locally; service worker + IndexedDB will keep app usable
    if(!RT.db || !RT.room || !navigator.onLine){
      PUBQ.push(Object.assign({clientId:RT.client,ts:Date.now()},action));
      return;
    }
    RT.db.collection('boards').doc(RT.room).collection('actions')
      .add(Object.assign({clientId:RT.client,ts:Date.now()},action))
      .catch(e=>{ console.error('publish',e); PUBQ.push(Object.assign({clientId:RT.client,ts:Date.now()},action)); });
  }

  const idIndex=id=>S.strokes.findIndex(s=>s.id===id);
  function applyRemote(a){
    if(a.type==='draw'){
      if(idIndex(a.stroke.id)===-1) S.strokes.push({id:a.stroke.id,w:a.stroke.w,color:a.stroke.color,pts:a.stroke.pts.slice(),bounds:null});
    } else if(a.type==='erase'||a.type==='delete'){
      const ids=a.ids||[]; for(let i=S.strokes.length-1;i>=0;i--){ if(ids.includes(S.strokes[i].id)) S.strokes.splice(i,1); }
    } else if(a.type==='move'){
      const {ids=[],dx=0,dy=0}=a; ids.forEach(id=>{ const i=idIndex(id); if(i!==-1) translateStroke(S.strokes[i],dx,dy); });
    } else if(a.type==='duplicate'){
      (a.strokes||[]).forEach(s=>{ if(idIndex(s.id)===-1) S.strokes.push({id:s.id,w:s.w,color:s.color,pts:s.pts.slice(),bounds:null}); });
    }
    if(S.sel.shown&&S.sel.set.size){ // keep selection box hugging moved content
      const bb=[...S.sel.set].reduce((m,s)=>{const b=bOf(s); return{ x0:Math.min(m.x0,b.minx), y0:Math.min(m.y0,b.miny), x1:Math.max(m.x1,b.maxx), y1:Math.max(m.y1,b.maxy) }},{x0:1/0,y0:1/0,x1:-1/0,y1:-1/0});
      if(isFinite(bb.x0)) { S.sel.start={x:bb.x0,y:bb.y0}; S.sel.end={x:bb.x1,y:bb.y1}; }
    }
    reqDraw();
  }
  async function connect(){ if(RT.unsub){RT.unsub();RT.unsub=null;} RT.room=(ui.roomInput.value||'').trim(); if(!RT.room){alert('Enter room-id');return;}
    const ok=await ensureFirebase(); if(!ok){ badge(ui.rtState,'offline','#eee'); return; }
    try{ badge(ui.rtState,'connecting','#fde68a'); const q=RT.db.collection('boards').doc(RT.room).collection('actions').orderBy('ts','asc').limit(5000);
      const snap=await q.get(); S.strokes.length=0; snap.forEach(doc=>{ const a=doc.data(); applyRemote(a,true); RT.lastSeen=a.ts||0; }); reqDraw();
      RT.unsub=RT.db.collection('boards').doc(RT.room).collection('actions').orderBy('ts','asc').where('ts','>',RT.lastSeen||0).onSnapshot(ss=>{ ss.docChanges().forEach(ch=>{ if(ch.type==='added'){ const a=ch.doc.data(); if(a.clientId===RT.client) return; applyRemote(a,false); } }); }); badge(ui.rtState,'online','#d1fae5');
    }catch(err){ alert('Connect failed: '+(err.message||err)); badge(ui.rtState,'offline','#eee'); }
  }
  ui.connectBtn.onclick=connect;
  // Flush any queued actions after we are online & connected
  async function flushQueue(){ if(!RT.db||!RT.room||PUBQ.length===0||!navigator.onLine) return; const batch=[...PUBQ]; PUBQ.length=0; for(const a of batch){ try{ await RT.db.collection('boards').doc(RT.room).collection('actions').add(a); }catch(e){ console.warn('repub',e); PUBQ.push(a); } } }
  addEventListener('online', ()=>{ badge(ui.rtState,'online?','#fde68a'); flushQueue(); reqDraw(); });
  addEventListener('offline', ()=>{ badge(ui.rtState,'offline','#eee'); });

  /* ===== Pencil, Mouse, Touch ===== */

  /*** NEW: Track last pointer initiator to block synthetic touches after Pencil ***/
  let lastPointer = { type: null, t: 0 };
  addEventListener('pointerdown', e => {
    lastPointer = { type: e.pointerType || null, t: performance.now() };
  }, { capture: true });
  function shouldBlockTouchForPen(){
    return S.pen.active || (lastPointer.type === 'pen' && (performance.now() - lastPointer.t) < 600);
  }
  /***************************************************************************/

  // Pencil
  cvs.addEventListener('pointerdown', e=>{ if(e.pointerType!=='pen') return; e.preventDefault(); S.pen.active=true; clearTimeout(S.pen.timer); try{ if(cvs.setPointerCapture) cvs.setPointerCapture(e.pointerId); }catch(_){} });
  cvs.addEventListener('pointerdown', e=>{ if(e.pointerType!=='pen') return; e.preventDefault();
    const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y); if((e.buttons&1)===0) return; (S.brush.mode==='draw'?beginStroke:beginErase)(w); setMode(S.brush.mode==='draw'?'draw':'erase'); reqDraw(); },{passive:false});
  cvs.addEventListener('pointermove', e=>{ if(e.pointerType!=='pen') return; e.preventDefault(); const events=(typeof e.getCoalescedEvents==='function')?e.getCoalescedEvents():[e]; for(const ev of events){ const p=getXY(ev.clientX,ev.clientY), w=scrToW(p.x,p.y); if(S.current.stroke) addPoint(w); if(S.current.erase) addErase(w); } reqDraw(); },{passive:false});
  function endPencil(e){ if(e){ try{ if(cvs.releasePointerCapture) cvs.releasePointerCapture(e.pointerId); }catch(_){} e.preventDefault(); }
    if(S.current.stroke) endStroke(); if(S.current.erase) endErase(); setMode('idle'); clearTimeout(S.pen.timer); S.pen.timer=setTimeout(()=>S.pen.active=false,S.pen.GRACE); reqDraw(); }
  addEventListener('pointerup',e=>{ if(e.pointerType!=='pen') return; endPencil(e); },{passive:false});
  addEventListener('pointercancel',e=>{ if(e.pointerType!=='pen') return; endPencil(e); },{passive:false});

  // Mouse (draw/erase, pan, selection move + Shift-select)
  let mouse={drawing:false,erasing:false,panning:false,pan0:null, movingSel:false, selecting:false};
  cvs.addEventListener('mousedown', e=>{
    if(e.button===0 && !e.shiftKey && S.sel.shown && S.sel.set.size){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y), r=rect(S.sel.start,S.sel.end); if(!rectHas(r,w)){ S.sel.shown=false; S.sel.set.clear(); reqDraw(); }}
    if(e.button===0 && e.shiftKey){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y); S.sel.active=true; S.sel.shown=true; S.sel.start=S.sel.end=w; mouse.selecting=true; setMode('selectRect'); reqDraw(); e.preventDefault(); return; }
    if(e.button===0 && !e.shiftKey && S.sel.shown && S.sel.set.size){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y), r=rect(S.sel.start,S.sel.end); if(rectHas(r,w)){ mouse.movingSel=true; S.I.mode='moveSel'; S.I.w0=w; S.I.moving={dx:0,dy:0}; setMode('moveSel'); e.preventDefault(); return; }}
    if(e.button===0 && !e.shiftKey && !mouse.movingSel){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y); if(S.brush.mode==='draw'){ beginStroke(w); mouse.drawing=true; setMode('draw'); } else { beginErase(w); mouse.erasing=true; setMode('erase'); } reqDraw(); }
    if(e.button===2){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y); const r=rect(S.sel.start||w,S.sel.end||w); if(S.sel.shown && S.sel.set.size && rectHas(r,w)){ showMenu(p.x,p.y); e.preventDefault(); return; } mouse.panning=true; mouse.pan0={x:e.clientX,y:e.clientY,tx:S.cam.tx,ty:S.cam.ty}; e.preventDefault(); }
  });
  cvs.addEventListener('mousemove', e=>{
    if(mouse.selecting && S.sel.active){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y); S.sel.end=w; reqDraw(); e.preventDefault(); return; }
    if(mouse.movingSel && S.I.mode==='moveSel'){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y), dx=w.x-S.I.w0.x, dy=w.y-S.I.w0.y; if(dx||dy){ moveSelBy(dx,dy); S.I.w0=w; S.I.moving.dx+=dx; S.I.moving.dy+=dy; reqDraw(); } e.preventDefault(); return; }
    if(mouse.drawing && S.current.stroke){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y); addPoint(w); reqDraw(); }
    if(mouse.erasing && S.current.erase){ const p=getXY(e.clientX,e.clientY), w=scrToW(p.x,p.y); addErase(w); reqDraw(); }
    if(mouse.panning && mouse.pan0){ const dx=e.clientX-mouse.pan0.x, dy=e.clientY-mouse.pan0.y; S.cam.tx=mouse.pan0.tx+dx; S.cam.ty=mouse.pan0.ty+dy; reqDraw(); }
  });
  addEventListener('mouseup', e=>{
    if(mouse.drawing){ endStroke(); mouse.drawing=false; reqDraw(); }
    if(mouse.erasing){ endErase(); mouse.erasing=false; reqDraw(); }
    if(mouse.panning && e.button===2){ mouse.panning=false; mouse.pan0=null; }
    if(mouse.selecting && S.sel.active){ S.sel.active=false; captureInRect(rect(S.sel.start,S.sel.end)); hud.textContent=S.sel.set.size?`Captured ${S.sel.set.size}`:'Captured 0'; setMode('idle'); reqDraw(); mouse.selecting=false; }
    if(mouse.movingSel && S.I.mode==='moveSel'){ S.I.mode='idle'; const moved=Math.abs(S.I.moving.dx)+Math.abs(S.I.moving.dy); if(moved>0) pushMove(S.I.moving.dx,S.I.moving.dy); S.I.moving={dx:0,dy:0}; reqDraw(); mouse.movingSel=false; }
  });
  cvs.addEventListener('contextmenu', e=> e.preventDefault());

  // Touch (selection + pinch, 2/3-finger undo/redo) â€” never start selection while erasing
  let g={startTouches:[], startTime:0, isTap:false};
  const LONG_MS=300, TOUCH_MENU_MS=450; let longT=null, menuT=null; const isStylus=(ev)=>[...(ev.touches||[])].some(t=>t.touchType==='stylus');
  function centroid(ts){ let x=0,y=0; for(const t of ts){x+=t.clientX;y+=t.clientY;} return {x:x/ts.length,y:y/ts.length}; }
  function dist(a,b){ return Math.hypot(a.x-b.x,a.y-b.y); }

  cvs.addEventListener('touchstart', ev=>{
    if(ev.touches.length===2||ev.touches.length===3){ g.startTouches=[...ev.touches].map(t=>({x:t.clientX,y:t.clientY,id:t.identifier})); g.startTime=Date.now(); g.isTap=true; return; }
    // HARD BLOCK: if Pencil is active or just initiated, do not allow selection via touch
    if (shouldBlockTouchForPen()) { ev.preventDefault(); return; }
    if(S.brush.mode!=='draw' || S.current.erase){ ev.preventDefault(); return; } // do not enter selection while erasing

    const t=ev.changedTouches[0], p=getXY(t.clientX,t.clientY), w=scrToW(p.x,p.y);
    if(S.sel.shown && S.sel.set.size){ const r=rect(S.sel.start,S.sel.end); if(rectHas(r,w)){ ev.preventDefault(); S.I.mode='moveSel'; S.I.w0=w; S.I.moving={dx:0,dy:0}; setMode('moveSel'); clearTimeout(menuT); menuT=setTimeout(()=>showMenu(p.x,p.y),TOUCH_MENU_MS); return; }}
    ev.preventDefault(); clearTimeout(longT); longT=setTimeout(()=>{ S.sel.active=true; S.sel.shown=true; S.sel.start=w; S.sel.end=w; setMode('selectRect'); reqDraw(); },LONG_MS);
  },{passive:false});

  cvs.addEventListener('touchmove', ev=>{
    // BLOCK selection/move updates if Pencil is active or just initiated
    if (shouldBlockTouchForPen()) { ev.preventDefault(); return; }

    if(g.isTap && g.startTouches.length===ev.touches.length){ for(let i=0;i<g.startTouches.length;i++){ const s=g.startTouches[i], c=[...ev.touches].find(t=>t.identifier===s.id); if(!c) continue; if(Math.abs(c.clientX-s.x)>20||Math.abs(c.clientY-s.y)>20){ g.isTap=false; break; } } }
    const ts=[...ev.touches];
    if(ts.length>=2 && g.startTouches.length===ts.length){ let moved=false; for(let i=0;i<g.startTouches.length;i++){ const s=g.startTouches[i], c=ts.find(t=>t.identifier===s.id); if(!c) continue; if(Math.abs(c.clientX-s.x)>30||Math.abs(c.clientY-s.y)>30){ moved=true; break; } }
      if(moved){ const c=centroid(ts), a={x:ts[0].clientX,y:ts[0].clientY}, b={x:ts[1].clientX||ts[0].clientX,y:ts[1].clientY||ts[0].clientY}, d=dist(a,b)||20; S.pinch={ startScale:S.cam.scale, p0dist:Math.max(20,d), worldAtCent:scrToW(c.x,c.y) }; setMode('pan'); g.startTouches=[]; g.startTime=0; ev.preventDefault(); return; } }
    if(S.pinch && ts.length>=2){ ev.preventDefault(); const a={x:ts[0].clientX,y:ts[0].clientY}; const b={x:ts[1].clientX||ts[0].clientX,y:ts[1].clientY||ts[0].clientY}; const d=dist(a,b), ratio=clamp((d||20)/S.pinch.p0dist,0.05,20); S.cam.scale=clamp(S.pinch.startScale*ratio,0.10,10); const c=centroid(ts); S.cam.tx=c.x-S.cam.scale*S.pinch.worldAtCent.x; S.cam.ty=c.y-S.cam.scale*S.pinch.worldAtCent.y; reqDraw(); return; }
    if(longT){ clearTimeout(longT); longT=null; }
    if(S.I.mode==='moveSel'){ ev.preventDefault(); clearTimeout(menuT); const t=ts[0], p=getXY(t.clientX,t.clientY), w=scrToW(p.x,p.y), dx=w.x-S.I.w0.x, dy=w.y-S.I.w0.y; if(dx||dy){ moveSelBy(dx,dy); S.I.w0=w; S.I.moving.dx+=dx; S.I.moving.dy+=dy; reqDraw(); } return; }
    if(S.sel.active){ ev.preventDefault(); const t=ts[0], p=getXY(t.clientX,t.clientY), w=scrToW(p.x,p.y); S.sel.end=w; reqDraw(); }
  },{passive:false});

  cvs.addEventListener('touchend', ev=>{
    // BLOCK selection finalize if Pencil is active or just initiated
    if (shouldBlockTouchForPen()) { ev.preventDefault(); return; }

    if(g.isTap && g.startTouches.length>=2 && ev.touches.length===0 && Date.now()-g.startTime<2500){ let moved=false; for(let i=0;i<g.startTouches.length;i++){ const s=g.startTouches[i], end=[...ev.changedTouches].find(t=>t.identifier===s.id); if(!end) continue; if(Math.abs(end.clientX-s.x)>20||Math.abs(end.clientY-s.y)>20){ moved=true; break; } }
      if(!moved){ if(g.startTouches.length===2) undo(); if(g.startTouches.length===3) redo(); } g.startTouches=[]; g.startTime=0; g.isTap=false; return; }
    g.startTouches=[]; g.startTime=0; g.isTap=false;
    if(S.pen.active){ ev.preventDefault(); return; }
    clearTimeout(menuT);
    if(S.pinch && ev.touches.length<2){ S.pinch=null; setMode('idle'); }
    if(S.I.mode==='moveSel'){ S.I.mode='idle'; const moved=Math.abs(S.I.moving.dx)+Math.abs(S.I.moving.dy); if(moved>0) pushMove(S.I.moving.dx,S.I.moving.dy); S.I.moving={dx:0,dy:0}; reqDraw(); }
    if(S.sel.active){ S.sel.active=false; captureInRect(rect(S.sel.start,S.sel.end)); hud.textContent=S.sel.set.size?`Captured ${S.sel.set.size}`:'Captured 0'; setMode('idle'); reqDraw(); }
  },{passive:false});
  addEventListener('touchcancel', ()=>{ g.startTouches=[]; g.startTime=0; g.isTap=false; },{passive:true});

  // Wheel zoom
  cvs.addEventListener('wheel', e=>{ e.preventDefault(); const {x,y}=getXY(e.clientX,e.clientY); const before=scrToW(x,y); const d=-Math.sign(e.deltaY)*0.2; S.cam.scale=clamp(S.cam.scale*(1+d),0.10,10); S.cam.tx=x-S.cam.scale*before.x; S.cam.ty=y-S.cam.scale*before.y; reqDraw(); },{passive:false});

  // Context actions
  ui.dupBtn.onclick=()=>{ if(!S.sel.set.size) return; const clones=[]; for(const s of S.sel.set){ const c={...s,id:uuid(),pts:s.pts.map(p=>({...p})),bounds:null}; S.strokes.push(c); clones.push(c); } S.history.push({type:'duplicate',clones}); S.redo.length=0; pub({type:'duplicate',strokes:clones.map(lite)}); hideMenu(); reqDraw(); };
  ui.delBtn.onclick=()=>{ if(!S.sel.set.size) return; const removed=[]; for(const s of S.sel.set){ const idx=S.strokes.indexOf(s); if(idx!==-1){ S.strokes.splice(idx,1); removed.push({idx,stroke:s}); } } S.history.push({type:'delete',removed}); S.redo.length=0; pub({type:'delete',ids:removed.map(r=>r.stroke.id)}); hideMenu(); reqDraw(); };

  // Selection helpers
  function captureInRect(r){ S.sel.set.clear(); const rbox={minx:r.x0,miny:r.y0,maxx:r.x1,maxy:r.y1}; for(const s of S.strokes){ const sb=bOf(s); const hit=S.capture==='contain' ? (sb.minx>=r.x0&&sb.maxx<=r.x1&&sb.miny>=r.y0&&sb.maxy<=r.y1) : boxesOverlap(rbox,sb); if(hit) S.sel.set.add(s); } }

  // Tests
  function runTests(){ const results=[];
    try{ const t={type:'move',dx:3,dy:4}; results.push(['object_literal_colons', t.dx===3&&t.dy===4]); }catch(err){ results.push(['object_literal_colons', false, String(err)]); }
    results.push(['hasCfg_valid', !!(FIREBASE_CONFIG && FIREBASE_CONFIG.appId)]);
    const x=200,y=200,w0=scrToW(x,y), s0=S.cam.scale, tx=S.cam.tx, ty=S.cam.ty; S.cam.scale=clamp(S.cam.scale*1.2,0.10,10); S.cam.tx=x-S.cam.scale*w0.x; S.cam.ty=y-S.cam.scale*w0.y; const w1=scrToW(x,y); results.push(['zoom_cursor_fixed', Math.abs(w0.x-w1.x)<1e-9 && Math.abs(w0.y-w1.y)<1e-9]); S.cam.scale=s0; S.cam.tx=tx; S.cam.ty=ty;
    const far={id:'t',w:2,color:'#111',pts:[{x:1000,y:1000},{x:1010,y:1010}]}; far.bounds=withPad(baseBounds(far.pts),far.w*0.5); const r={x0:0,y0:0,x1:50,y1:50}; const sb={minx:far.bounds.minx,maxx:far.bounds.maxx,miny:far.bounds.miny,maxy:far.bounds.maxy}; const rbox={minx:r.x0,miny:r.y0,maxx:r.x1,maxy:r.y1}; results.push(['far_not_overlap', !boxesOverlap(rbox,sb)]);
    results.push(['pen_grace>=120ms', S.pen.GRACE>=120]);
    // NEW: publishing queues when offline/unconfigured
    const q0=PUBQ.length; pub({type:'draw',stroke:{id:'temp',w:1,color:'#000',pts:[{x:0,y:0},{x:1,y:1}]}}); results.push(['pub_offline_queue', PUBQ.length===q0+1]);
    // NEW: applyRemote draw is idempotent
    const beforeCount=S.strokes.length; applyRemote({type:'draw',stroke:{id:'__test__',w:2,color:'#111',pts:[{x:0,y:0},{x:2,y:2}]}}); const afterOnce=S.strokes.length; applyRemote({type:'draw',stroke:{id:'__test__',w:2,color:'#111',pts:[{x:0,y:0},{x:2,y:2}]}}); const afterTwice=S.strokes.length; results.push(['applyRemote_idempotent', afterOnce===afterTwice]); if(afterTwice>beforeCount){ const idx=S.strokes.findIndex(s=>s.id==='__test__'); if(idx!==-1) S.strokes.splice(idx,1); }
    // NEW: env supports service workers (or not) â€” just a boolean check
    results.push(['sw_possible_boolean', 'serviceWorker' in navigator]);
    // NEW: flushQueue exists
    results.push(['flushQueue_exists', typeof flushQueue==='function']);
    // NEW: pencil guard logic sanity
    results.push(['shouldBlockTouch_idle_false', !shouldBlockTouchForPen()]);
    lastPointer={type:'pen',t:performance.now()}; results.push(['shouldBlockTouch_recent_pen_true', shouldBlockTouchForPen()]);
    console.table(results.map(([name,pass,extra])=>({test:name, pass, extra:extra||''})));
    return results.every(r=>r[1]); }
  window.runTests=runTests;

  /* ===== Init ===== */
  function init(){
    buildSwatches();
    updBrushUI();
    resize();
    try{ cvs.style.touchAction='none'; }catch(_){/* ignore */}
    addEventListener('resize',resize,{passive:true});
    addEventListener('orientationchange',resize,{passive:true});
    // Update RT badge initially based on connectivity
    badge(ui.rtState, navigator.onLine? 'online?':'offline', navigator.onLine? '#fde68a':'#eee');
    // Register a tiny Service Worker (inline) to cache the app shell for true offline loads
    if('serviceWorker' in navigator){
      const swCode = `const CACHE='board-v1';
self.addEventListener('install',e=>{e.waitUntil(caches.open(CACHE).then(c=>c.addAll(['./'])))});
self.addEventListener('activate',e=>{e.waitUntil(caches.keys().then(keys=>Promise.all(keys.filter(k=>k!==CACHE).map(k=>caches.delete(k)))))});
self.addEventListener('fetch',e=>{
  const url=new URL(e.request.url);
  // Only handle GETs; prefer cache-first for same-origin (the app shell)
  if(e.request.method!=='GET' || url.origin!==location.origin) return;
  e.respondWith(
    caches.match(e.request).then(res=> res || fetch(e.request).then(net=>{ const copy=net.clone(); caches.open(CACHE).then(c=>c.put(e.request, copy)).catch(()=>{}); return net; }).catch(()=>res))
  );
});`;
      try{
        const blob=new Blob([swCode],{type:'text/javascript'});
        const url=URL.createObjectURL(blob);
        navigator.serviceWorker.register(url).catch(console.warn);
      }catch(e){ console.warn('sw',e); }
    }
  }
  init();
})();
</script>
</body>
</html>
